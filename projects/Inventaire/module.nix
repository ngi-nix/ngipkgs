{
  config,
  lib,
  pkgs,
  ...
}:
let
  cfg = config.services.inventaire;
  settingsFormat = pkgs.formats.json { };
  settingsJson = settingsFormat.generate "local.json" cfg.settings;
  settingsCJS = pkgs.runCommandNoCC "local.cjs" { } ''
    cat <<EOF >$out
    // Settings generated via Nix

    module.exports =
    EOF
    cat ${settingsJson} >> $out
  '';

  settingsLinks = ''
    Links for settings (make sure to look at the version that's actually packaged):
    - <a href="https://codeberg.org/inventaire/inventaire/src/branch/main/server/types/config.ts">Types</a>
    - <a href="https://codeberg.org/inventaire/inventaire/src/branch/main/config/default.cjs">Defaults</a>
  '';
  mkExtraSettingsFileOption =
    mode:
    lib.options.mkOption {
      type = lib.types.nullOr lib.types.path;
      description = ''
        Path to a .cjs file that exists at runtime with any additional setting.

        Notes:
        - The passed path (if any) will be set up as `config/local-${mode}.cjs`, to override the built-in defaults and values from the main `settings` attribute
        - These settings are not world-readable (assuming you're passing a path that isn't generated by Nix), and thus suitable for secrets

      ''
      + settingsLinks;
      default = null;
    };
in
{
  options.services.inventaire = {
    enable = lib.options.mkEnableOption "Inventaire server";

    package = lib.options.mkPackageOption pkgs "inventaire" { };

    settings = lib.options.mkOption {
      type = settingsFormat.type;
      description = ''
        Settings that you wish to set for the service.

        Notes:
        - The settings here will be set up as `config/local.cjs`, to override the built-in defaults
        - These settings are world-readable, and thus not suitable for secrets

      ''
      + settingsLinks;
      default = {
        hostname = "localhost";
        port = 3006;

        # Storage location defaults
        leveldb.directory = "${config.services.inventaire.stateDir}/db/leveldb";
        mediaStorage.local.directory = "${config.services.inventaire.stateDir}/storage";
      };
    };

    inProductionMode = lib.options.mkOption {
      type = lib.types.bool;
      description = ''
        Whether to run in development or production mode.

        Will affect which default settings get loaded, and which of the extra settings files options will be relevant.
      '';
      default = false;
      example = true;
    };

    openFirewall = lib.options.mkOption {
      type = lib.types.bool;
      description = ''
        Whether to open the `port` specified in `settings` in the firewall.
      '';
      default = false;
      example = true;
    };

    extraDevelopmentSettingsFile = mkExtraSettingsFileOption "development";

    extraProductionSettingsFile = mkExtraSettingsFileOption "production";

    stateDir = lib.options.mkOption {
      type = lib.types.path;
      description = ''
        Directory in which Inventaire will run & put its data into.
      '';
      default = "/var/lib/inventaire";
    };
  };

  config = lib.mkIf cfg.enable {
    assertions = [
      {
        assertion = !cfg.openFirewall || cfg.settings ? port;
        message = "To open a port in the firewall for Inventaire, you need to specify `services.inventaire.settings.port`!";
      }
    ];

    users = {
      groups.inventaire = { };
      users.inventaire = {
        description = "User that runs Inventaire";
        home = cfg.stateDir;
        createHome = true;
        isSystemUser = true;
        group = "inventaire";
      };
    };

    networking.firewall.allowedTCPPorts = lib.optionals cfg.openFirewall [
      cfg.settings.port
    ];

    systemd.services."inventaire" = {
      description = "Inventaire server";

      wantedBy = [ "multi-user.target" ];
      after = [ "network.target" ];

      environment = {
        NODE_ENV = if cfg.inProductionMode then "production" else "development";
      };

      serviceConfig = {
        Type = "exec";
        User = "inventaire";
        Group = "inventaire";
        WorkingDirectory = cfg.stateDir;
        ExecStart = lib.getExe (
          pkgs.writeShellApplication {
            name = "inventaire-launch";

            runtimeInputs = with pkgs; [
              cfg.package # Inventaire package to use
              graphicsmagick # server-side image resizing
            ];

            text = ''
              mkdir -p config db/leveldb keys
              for configFile in ${cfg.package}/lib/node_modules/inventaire/config/*.cjs; do
                ln -fs "$configFile" config/"$(basename "$configFile")"
              done

              ln -fs ${settingsCJS} config/local.cjs

              rm -f config/local-development.cjs
              rm -f config/local-production.cjs
            ''
            + lib.optionalString (cfg.extraDevelopmentSettingsFile != null) ''
              ln -s ${cfg.extraDevelopmentSettingsFile} config/local-development.cjs
            ''
            + lib.optionalString (cfg.extraProductionSettingsFile != null) ''
              ln -s ${cfg.extraProductionSettingsFile} config/local-production.cjs
            ''
            + ''

              exec inventaire
            '';
          }
        );
      };
    };

    programs.bash.interactiveShellInit = lib.mkIf (config ? demo && config.demo) ''
      echo "Inventaire is starting. Please wait ..."
      until systemctl show inventaire.service | grep -q ActiveState=active; do sleep 1; done
      echo "Inventaire is ready at http://localhost:${toString cfg.settings.port}"
    '';
  };
}
